package util

import (
	"context"
	"github.com/sashabaranov/go-openai"
	"log"
)

func GetGPTResponseChatTest(prompt string, model string, maxTokens int) string {
	// 2016.5
	//return "Here's the `main.go` file that solves both parts of the Day 5 challenge. This file assumes `input.txt` contains the Door ID as a single line of text.\n\n```go\npackage main\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc computeMD5(text string) string {\n\thash := md5.Sum([]byte(text))\n\treturn hex.EncodeToString(hash[:])\n}\n\nfunc findPassword(doorID string) string {\n\tvar password [8]byte\n\tcount := 0\n\tindex := 0\n\n\tfor count \u003c 8 {\n\t\thash := computeMD5(doorID + strconv.Itoa(index))\n\t\tif strings.HasPrefix(hash, \"00000\") {\n\t\t\tpassword[count] = hash[5]\n\t\t\tcount++\n\t\t}\n\t\tindex++\n\t}\n\treturn string(password[:])\n}\n\nfunc findSecondPassword(doorID string) string {\n\tpassword := make([]byte, 8)\n\tfilledPositions := make(map[int]bool)\n\tindex := 0\n\n\tfor len(filledPositions) \u003c 8 {\n\t\thash := computeMD5(doorID + strconv.Itoa(index))\n\t\tif strings.HasPrefix(hash, \"00000\") {\n\t\t\tposition, err := strconv.Atoi(string(hash[5]))\n\t\t\tif err == nil \u0026\u0026 position \u003c 8 \u0026\u0026 !filledPositions[position] {\n\t\t\t\tpassword[position] = hash[6]\n\t\t\t\tfilledPositions[position] = true\n\t\t\t}\n\t\t}\n\t\tindex++\n\t}\n\treturn string(password)\n}\n\nfunc main() {\n\tinput, err := ioutil.ReadFile(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error reading input.txt:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tdoorID := strings.TrimSpace(string(input))\n\tpartOnePassword := findPassword(doorID)\n\tfmt.Println(partOnePassword)\n\n\tpartTwoPassword := findSecondPassword(doorID)\n\tfmt.Println(partTwoPassword)\n}\n```\n\nTo compile and run this program, save the content in a file named `main.go` and place it in the same directory as the `input.txt` file. To execute the program, use the following commands:\n\n```bash\ngo build -o password_finder\n./password_finder\n```\n\nThis will print out the two passwords (part one and part two) as required.\n\nThe program works as follows:\n1. `computeMD5` computes the MD5 hash of a given string.\n2. `findPassword` finds the first password by incrementing an index until it finds 8 hashes starting with five zeroes.\n3. `findSecondPassword` finds the second password by checking for hashes that indicate a position and character, and it fills the password accordingly - it checks if the position is within the range 0-7 and if it has not been filled yet.\n4. `main` reads the input from `input.txt`, trims any leading or trailing whitespace, and calls the functions to find and print both passwords."
	// 2016.6
	//return "To solve the task, we can create a Go program that reads the input from \"input.txt\", counts the frequency of each character in each column position, and then constructs two versions of the message: one using the most common character and the other using the least common character for each position.\n\nBelow is the Go program as \"main.go\" that will perform the described task:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sort\"\n)\n\nfunc main() {\n\t// Open the file.\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to open file: %s\", err)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcharCounters := make([]map[rune]int, 0)\n\n\t// Process each line in the input file.\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tfor i, c := range line {\n\t\t\tif len(charCounters) <= i {\n\t\t\t\tcharCounters = append(charCounters, make(map[rune]int))\n\t\t\t}\n\t\t\tcharCounters[i][c]++\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatalf(\"scanner error: %s\", err)\n\t}\n\n\t// Function to sort and find the most/least common character.\n\tfindChar := func(counter map[rune]int, mostCommon bool) rune {\n\t\ttype kv struct {\n\t\t\tKey   rune\n\t\t\tValue int\n\t\t}\n\t\tvar sortedPairs []kv\n\t\tfor k, v := range counter {\n\t\t\tsortedPairs = append(sortedPairs, kv{k, v})\n\t\t}\n\t\tsort.Slice(sortedPairs, func(i, j int) bool {\n\t\t\tif mostCommon {\n\t\t\t\treturn sortedPairs[i].Value > sortedPairs[j].Value\n\t\t\t}\n\t\t\treturn sortedPairs[i].Value < sortedPairs[j].Value\n\t\t})\n\t\treturn sortedPairs[0].Key\n\t}\n\tmostCommonMessage := \"\"\n\tleastCommonMessage := \"\"\n\n\t// Construct most and least common messages.\n\tfor _, counter := range charCounters {\n\t\tmostCommonMessage += string(findChar(counter, true))\n\t\tleastCommonMessage += string(findChar(counter, false))\n\t}\n\n\tfmt.Printf(\"Most common message (Part 1): %s\\n\", mostCommonMessage)\n\tfmt.Printf(\"Least common message (Part 2): %s\\n\", leastCommonMessage)\n}\n```\n\nThis code reads the"
	//return "Here is the \"main.go\" for the given task:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\ntype letter struct {\n\tchar  rune\n\tcount int\n}\n\ntype letters []letter\n\nfunc (l letters) Len() int {\n\treturn len(l)\n}\n\nfunc (l letters) Less(i, j int) bool {\n\treturn l[i].count > l[j].count\n}\n\nfunc (l letters) Swap(i, j int) {\n\tl[i], l[j] = l[j], l[i]\n}\n\nfunc main() {\n\tinput, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening input.txt: \", err)\n\t\tos.Exit(1)\n\t}\n\n\tdefer input.Close()\n\n\tscanner := bufio.NewScanner(input)\n\n\tvar data [][]rune\n\tfor scanner.Scan() {\n\t\tdata = append(data, []rune(scanner.Text()))\n\t}\n\n\tif len(data) == 0 {\n\t\tfmt.Println(\"No data provided in input.txt\")\n\t\treturn\n\t}\n\n\tvar message []rune\n\tlength := len(data[0])\n\tfor i := 0; i < length; i++ {\n\t\tcounter := make(map[rune]int)\n\t\tfor j := 0; j < len(data); j++ {\n\t\t\tcounter[data[j][i]]++\n\t\t}\n\n\t\tvar counted letters\n\t\tfor k, v := range counter {\n\t\t\tcounted = append(counted, letter{k, v})\n\t\t}\n\n\t\tsort.Sort(counted)\n\t\tmessage = append(message, counted[0].char)\n\n\t}\n\n\tfmt.Println(\"The message is: \", string(message))\n\n}\n```\n\nSave this as \"main.go\" and give the input data in \"input.txt\" file in the same directory."
	//2016.9
	return "Below is the solution for the task described. This Go program reads the input from \"input.txt\", decompresses the data as per the rules provided, and prints out the length of the decompressed data.\n\nCreate the \"main.go\" file with the following code:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tinput, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer input.Close()\n\n\tscanner := bufio.NewScanner(input)\n\tscanner.Scan()\n\tcompressed := strings.ReplaceAll(scanner.Text(), \" \", \"\") // Removing whitespace\n\n\tdecompressedLength := 0\n\n\tfor i := 0; i < len(compressed); {\n\t\tif compressed[i] == '(' {\n\t\t\tendMarker := strings.Index(compressed[i:], \")\")\n\t\t\tif endMarker == -1 {\n\t\t\t\tpanic(\"Invalid input: marker not closed\")\n\t\t\t}\n\t\t\tmarker := compressed[i+1 : i+endMarker]\n\t\t\tparts := strings.Split(marker, \"x\")\n\n\t\t\tif len(parts) != 2 {\n\t\t\t\tpanic(\"Invalid marker format\")\n\t\t\t}\n\n\t\t\tnumCharsToRepeat, err := strconv.Atoi(parts[0])\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tnumRepetitions, err := strconv.Atoi(parts[1])\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\t// Calculate decompressed length\n\t\t\tdecompressedLength += numCharsToRepeat * numRepetitions\n\n\t\t\t// Skip to the end of the repeated section\n\t\t\ti += endMarker + 1 + numCharsToRepeat\n\t\t} else {\n\t\t\tdecompressedLength++\n\t\t\ti++\n\t\t}\n\t}\n\n\tfmt.Print(decompressedLength)\n}\n```\n\nMake sure to place \"input.txt\" in the same directory as your \"main.go\" file before running the program.\n\nTo compile and run it, you can simply use:\n\n```sh\ngo run main.go\n```\n\nThis should print out the length of the decompressed data. Please ensure that the provided input follows the exact format that was described, as the program will panic on any input that doesn't strictly adhere to it."
}
func GetGPTResponseChat(prompt string, model string, maxTokens int) string {
	apiKey := GptApiKey
	if apiKey == "" {
		return "Key is empty"
	}
	client := openai.NewClient(apiKey)
	resp, err := client.CreateChatCompletion(
		context.Background(),
		openai.ChatCompletionRequest{
			Model:     model,
			MaxTokens: maxTokens,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleUser,
					Content: prompt,
				},
			},
		},
	)

	if err != nil {
		log.Fatalln(err)
	}

	return resp.Choices[0].Message.Content
}
